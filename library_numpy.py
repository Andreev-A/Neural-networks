import numpy as np

#  основами работы с массивами

# мы записали данные - рост, вес и обхват шеи одного человека в список
data = [1.72, 54, 36.2]

# убедимся, что это список с помощью функции type()
print(type(data))  # list

# преобразуем список в массив Numpy
data_Numpy = np.array(data)
print(data_Numpy)  # array([1.72 54. 36.2])

# если у нас несколько наблюдений, то нужна матрица, т.е. по сути, несколько векторов
data_matrix = np.array([[1.72, 54, 36.2], [1.74, 58, 36.3], [1.68, 52, 32.9]])
print(data_matrix)
# array([[1.72 54. 36.2]
#        [1.74 58. 36.3]
#        [1.68 52. 32.9]])

# мы можем посмотреть размерность матрицы (количество строк и столбцов)
print(data_matrix.shape)  # (3, 3)
######################################################################################################################
#  умножить один вектор на другой

# даны два вектора в виде массивов Numpy
a = np.array([1.72, 54])  # вектор данных
w = np.array([19.86, 0.05])  # вектор весов

# перемножим их вручную
print(1.72 * 19.86 + 54 * 0.05)  # 36.8592

# используем скалярное произведение векторов
print(np.dot(a, w))  # 36.8592
######################################################################################################################
# Косинусное сходство
# Представление данных в форме вектора имеет ещё одно полезное свойство. Мы можем измерить близость двух векторов или
# угол между ними. Чем угол меньше, тем они ближе. В этой формуле мы умножаем один вектор на другой и делим на
# произведение их длин. Результатом будет косинус угла θ между ними. Зная косинус, мы можем найти сам угол в градусах.
# В первую очередь найдем косинус угла по формуле - b * c / bLen * cLen

# даны два вектора (данные двух человек) нам нужно понять, насколько они схожи
b = np.array([1.72, 54, 36.2])
c = np.array([1.56, 47, 30.0])

# вначале выполним операции в числителе формулы
numerator = np.dot(b, c)

# теперь займемся знаменателем и (1) рассчитаем длины (по большому счету, это теорема Пифагора)
bLen = np.linalg.norm(b)
cLen = np.linalg.norm(c)

# (2) перемножим их
denominator = bLen * cLen

# посмотрим, чему равен косинус угла между векторами
cosine = numerator / denominator
print(cosine)  # 0.9997468709497721

# Теперь рассчитаем угол в градусах

# для этого вначале вычислим угол в радианах
angle_radians = np.arccos(cosine)

# затем в градусах
angle_degrees = angle_radians * 360 / 2 / np.pi
print(angle_degrees)  # 1.2891925481394304
# Как мы видим угол чрезвычайно мал, а значит векторы очень близки друг к другу. Мы будем на практике применять
# косинусное сходство или близость векторов, например, при построении рекомендательных систем для сопутствующих товаров
# в интернет-магазине.
#################################################################################################################
my_list = [1, 2, 3, 4, 5]  # Задание списка чисел с названием my_list
numpy_arr = np.array(my_list)  # Вызов np.array() превращает список в массив чисел
print(numpy_arr)  # Проверка результата
print(type(numpy_arr))  # Вызов type() сообщает тип данных значения переменной numpy_arr

new_arr = np.arange(1, 6)  # Вызов arange(1, 6) задает массив значений от 1 до (не включая) 6
print(new_arr)  # Проверка результата

# Массив будет сохранен в переменной "arr"
arr = np.random.randint(1, 11, 5)  # От 1 до (не включая) 11 - границы массива, а число 5 - общее кол-во чисел
print(arr)  # Проверка результата

arr = np.array([1, 2, 3, 45, 7])  # Вот, пожалуйста - массив только из целых чисел
print(arr.dtype)  # Здесь выясняется тип данных: int64 ( цифра обозначает объем памяти, которую занимает единица данных.)
rr = np.array([1.23, 7.1, 3.14])  # Здесь массив содержит уже дробные числа
print(arr.dtype)  # Тип этих данных: float64
arr = np.array(["First", "Second", "blabla", 12345])  # А вот тут добавлены разные строки (фактически - текстовые данные)
print(arr.dtype)  # И тип данных будет <U6, где все значения - строки длиной не более 6 символов

# Если число – это просто число, то его называют скаляром. Например, 4 – скаляр, [4] – массив.
# Несколько чисел в линию в квадратных скобках – это вектор. Например, [1 2] – вектор.
# Если есть и линия (ряд), и столбик, будто это таблица, то это матрица. Например:
#  [[-4 -5]
#   [ 2 -1]]
# Это все одна матрица.
# Чаще всего вы встретите не просто матрицы, а матрицы из матриц, одно внутри другого – для наибольшей вместимости. Их
# именуют тензорами (что это такое – вы подробнее узнаете в следующих занятиях). Например:
#  [[[-4 -5]
#    [ 2 -1]]
#   [[ 4 -1]
#    [-4  0]]
#   [[ 0 -2]
#    [-4 -3]]]
# Это уже тензор.
tensor = np.random.randint(-5, 5, (3, 2, 2))  # Во вторых скобках заданы размеры тензора в высоту, ширину, глубину (оси X,Y,Z)
print(tensor)                                   # Вывод трехмерного тензора

# Свойства для определения параметров таких больших массивов
# .ndim сообщает, сколько измерений в тензоре (может быть и больше 3-х!);
# .shape сообщает форму массива: насколько каждое из измерений велико в высоту/ширину/глубину (т.е. по столбцам, строкам и слоям);
# .size сообщает, сколько в тензоре всего занятых мест. Посмотрим на работу методов в действии:
print('Количество осей: ',tensor.ndim)
print('Форма массива: ',tensor.shape)
print('Количество значений: ',tensor.size)

array_1D = np.random.randint(-5, 5, 4)                        # Задается одномерный массив
print(array_1D)
array_2D = random_matrix = np.random.randint(-5, 5, (5, 2))   # Задается двумерный массив
print(array_2D)
array_5D = np.random.randint(-5, 5, (2, 2, 2, 2, 2))          # Задается пятимерный массив
print(array_5D)

tensor = np.random.randint(-10, 10, (3, 2, 2))  # Создание трехмерного тензора
print(tensor[2])                                # Выделение одного из его слоев (слой №2 - отдельная матрица)
                                                # На место в тензоре также укажет количество квадратных скобок
print(tensor[2, 1])                             # Выделение вектора под индексом места 1
                                                # Этот вектор берется из матрицы с индексом 2
                                                # Это видно, если сравнить результаты кода этой и предыдущей ячеек
print(tensor[2, 1, 0])                          # Здесь способ найти отдельное число под индексом 0
                                                # Число взято из слоя 2, строки 1 и столбца 0 тензора

matrix = np.random.randint(-10, 10, (5, 5))     # Значения матрицы случайны в пределах (-10, 10), 5 строк и 5 столбцов
print(matrix)                                   # Проверка результата
print(matrix[:3])                               # Здесь знак двоеточия дает указание взять все значения первых трёх строк
print(matrix[0])                                # А если нужно взять лишь 1-ю строку, то это делается так:
                                                # Напоминение: отсчёт индексов всегда ведётся с нуля!
print(matrix[:, 0])                # Обратите внимание на конструкцию в квадратных скобках: этот способ дает первый столбец матрицы
print(matrix[:, 1])                # А здесь выделяется второй столбец
print(matrix[1, 2])                # Выделение элемента второй строки третьего столбца

arr_1 = np.random.randint(-10, 10, 5)
arr_2 = np.random.randint(-10, 10, 5)
print(arr_1)
print(arr_2)
print(arr_1 + arr_2)                     # Поэлементное сложение двух массивов
print(arr_1 * arr_2)                     # Поэлементное умножение двух массивов
print(arr_1 / arr_2)                     # Поэлементное деление первого массива на второй
print(arr_1 * 5)                         # Умножение каждого элемента массива "arr_1" на число 5
print(arr_1 / 7)                         # Деление каждого элемента массива "arr_1" на число 7
print(arr_1 ** 3)                        # Возведение каждого элемента массива "arr_1" в степень 3

my_array = np.random.randint(-10, 10, (5, 5))   # Создание массива
print(my_array)                                 # И вывод его на экран
print("Сумма всех элементов: ", my_array.sum())
print("Среднее всех элементов: ", my_array.mean())
print("Максимум всех элементов: ", my_array.max())
print("Минимум всех элементов: ", my_array.min())

# Важный момент: попробуйте в скобках этих команд написать слово axis («ось»). Если задать axis=1, то команда будет
# применяться ко всем числам каждой строки, а если axis=0, то ко всем числам каждого столбца:
print("Сумма всех элементов по первой оси: ", my_array.sum(axis=1))
print("Среднее всех элементов по первой оси: ", my_array.mean(axis=1))
print("Максимум всех элементов по первой оси: ", my_array.max(axis=1))
print("Минимум всех элементов по первой оси: ", my_array.min(axis=1))
# .in1d(array1, array2) сравнивает поэлементно два массива



# Получение списка BMP-файлов
# Чтобы получить список BMP-файлов из каталогаBengaliBMPConvert, используйте:
# import glob
# filelist = glob.glob('BengaliBMPConvert/*.bmp')
# С другой стороны, если вы уже знаете имена файлов, просто поместите их в последовательность:
# filelist = 'file1.bmp', 'file2.bmp', 'file3.bmp'
# Объединение всех изображений в один массив numpy
# Объединить все изображения в один массив:
# x = np.array([np.array(Image.open(fname)) for fname in filelist])
# Маринование массива numpy
# Чтобы сохранить массив numpy в файл с помощью pickle:
# import pickle
# pickle.dump( x, filehandle, protocol=2 )
# где xмассив numpy должен быть сохранен, filehandleявляется дескриптором для файла pickle, например
# open('filename.p', 'wb'), и protocol=2 сообщает pickle использовать его текущий формат, а не какой-то древний
# устаревший формат.
# Кроме того, массивы numpy можно мариновать, используя методы, поставляемые numpy (hat tip: tegan ). Чтобы сбросить
# массив x в файл file.npy, используйте:
# x.dump('file.npy')
# Чтобы загрузить массив x обратно из файла:
# x = np.load('file.npy')
